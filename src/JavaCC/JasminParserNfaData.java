/* Generated by: JavaCC 21 Parser Generator. JasminParserNfaData.java */
import java.util.Arrays;
import java.util.BitSet;
import java.util.EnumSet;
/**
 * Holder class for the data used by JasminParserLexer
 * to do the NFA thang
 */
class JasminParserNfaData implements JasminParserConstants {
    // The functional interface that represents 
    // the acceptance method of an NFA state
    static interface NfaFunction {
        TokenType apply(int ch, BitSet bs, EnumSet<TokenType> validTypes);
    }
    static private NfaFunction[] nfaFunctions;
    // This data holder class is never instantiated
    private JasminParserNfaData() {
    }

    /**
   * @param the lexical state
   * @return the table of function pointers that implement the lexical state
   */
    static final NfaFunction[] getFunctionTableMap(LexicalState lexicalState) {
        // We only have one lexical state in this case, so we return that!
        return nfaFunctions;
    }

    // Initialize the various NFA method tables
    static {
        NFA_FUNCTIONS_DEFAULT_init();
    }
    static TokenType NFA_COMPOSITE_0(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        TokenType type= null;
        if (ch== 'a') {
            nextStates.set(18);
        }
        else if (ch== 'c') {
            nextStates.set(99);
        }
        else if (ch== 'e') {
            nextStates.set(59);
            nextStates.set(86);
        }
        else if (ch== 'g') {
            nextStates.set(165);
        }
        else if (ch== 'i') {
            nextStates.set(40);
            nextStates.set(65);
            nextStates.set(133);
            nextStates.set(171);
            nextStates.set(78);
            nextStates.set(77);
            nextStates.set(42);
            nextStates.set(123);
            nextStates.set(56);
            nextStates.set(122);
            nextStates.set(164);
        }
        else if (ch== 'l') {
            nextStates.set(137);
            nextStates.set(152);
            nextStates.set(89);
        }
        else if (ch== 'm') {
            nextStates.set(63);
        }
        else if (ch== 'p') {
            nextStates.set(112);
        }
        else if (ch== 'r') {
            nextStates.set(135);
        }
        else if (ch== 's') {
            nextStates.set(7);
            nextStates.set(23);
            nextStates.set(22);
        }
        else if (ch>='A'&&ch<='Z') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) type= TokenType.IDENTIFIER;
        }
        if (ch>='a'&&ch<='z') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) type= TokenType.IDENTIFIER;
        }
        else if (ch== '>') {
            if (validTypes.contains(TokenType.GREAT)) type= TokenType.GREAT;
        }
        else if (ch== '<') {
            if (validTypes.contains(TokenType.LESS)) type= TokenType.LESS;
        }
        else if (ch== ')') {
            if (validTypes.contains(TokenType.CLOSE_PAREN)) type= TokenType.CLOSE_PAREN;
        }
        else if (ch== '(') {
            if (validTypes.contains(TokenType.OPEN_PAREN)) type= TokenType.OPEN_PAREN;
        }
        else if (ch== '/') {
            if (validTypes.contains(TokenType.SLASH)) type= TokenType.SLASH;
        }
        else if (ch== 'V') {
            if (validTypes.contains(TokenType.VOID)) type= TokenType.VOID;
        }
        else if (ch== 'I') {
            if (validTypes.contains(TokenType.INT)) type= TokenType.INT;
        }
        else if (ch== ':') {
            if (validTypes.contains(TokenType.DOUBLE_DOT)) type= TokenType.DOUBLE_DOT;
        }
        else if (ch== ';') {
            if (validTypes.contains(TokenType.SEMICOLON)) type= TokenType.SEMICOLON;
        }
        else if (ch== '.') {
            if (validTypes.contains(TokenType.DOT)) type= TokenType.DOT;
        }
        else if (ch>='0'&&ch<='9') {
            nextStates.set(148);
            if (validTypes.contains(TokenType.INTEGER)) type= TokenType.INTEGER;
        }
        else if (ch== '\n') {
            if (validTypes.contains(TokenType._TOKEN_4)) type= TokenType._TOKEN_4;
        }
        else if (ch== '\r') {
            if (validTypes.contains(TokenType._TOKEN_3)) type= TokenType._TOKEN_3;
        }
        else if (ch== '\t') {
            if (validTypes.contains(TokenType._TOKEN_2)) type= TokenType._TOKEN_2;
        }
        else if (ch== ' ') {
            if (validTypes.contains(TokenType._TOKEN_1)) type= TokenType._TOKEN_1;
        }
        return type;
    }

    static TokenType NFA_COMPOSITE_1(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        TokenType type= null;
        if (ch>='A'&&ch<='Z') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) type= TokenType.IDENTIFIER;
        }
        else if (ch>='a'&&ch<='z') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) type= TokenType.IDENTIFIER;
        }
        return type;
    }

    static TokenType NFA_COMPOSITE_2(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        TokenType type= null;
        if (ch>='0'&&ch<='9') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) type= TokenType.IDENTIFIER;
        }
        else if (ch>='A'&&ch<='Z') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) type= TokenType.IDENTIFIER;
        }
        else if (ch== '_') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) type= TokenType.IDENTIFIER;
        }
        else if (ch>='a'&&ch<='z') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) type= TokenType.IDENTIFIER;
        }
        return type;
    }

    static TokenType NFA_3(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(139);
        }
        return null;
    }

    static TokenType NFA_4(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== ' ') {
            if (validTypes.contains(TokenType._TOKEN_1)) return TokenType._TOKEN_1;
        }
        return null;
    }

    static TokenType NFA_5(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'r') {
            nextStates.set(127);
        }
        return null;
    }

    static TokenType NFA_6(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '2') {
            if (validTypes.contains(TokenType.ISTORE_2)) return TokenType.ISTORE_2;
        }
        return null;
    }

    static TokenType NFA_7(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(105);
        }
        return null;
    }

    static TokenType NFA_8(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            if (validTypes.contains(TokenType.GO_TO)) return TokenType.GO_TO;
        }
        return null;
    }

    static TokenType NFA_9(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(84);
        }
        return null;
    }

    static TokenType NFA_10(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'd') {
            if (validTypes.contains(TokenType.METHOD)) return TokenType.METHOD;
        }
        return null;
    }

    static TokenType NFA_11(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'g') {
            nextStates.set(165);
        }
        return null;
    }

    static TokenType NFA_12(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            if (validTypes.contains(TokenType.RETURN)) return TokenType.RETURN;
        }
        return null;
    }

    static TokenType NFA_13(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'c') {
            nextStates.set(33);
        }
        return null;
    }

    static TokenType NFA_14(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(5);
        }
        return null;
    }

    static TokenType NFA_15(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(13);
        }
        return null;
    }

    static TokenType NFA_16(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '0') {
            if (validTypes.contains(TokenType.ICONST_0)) return TokenType.ICONST_0;
        }
        return null;
    }

    static TokenType NFA_17(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(93);
        }
        return null;
    }

    static TokenType NFA_18(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(45);
        }
        return null;
    }

    static TokenType NFA_19(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'd') {
            if (validTypes.contains(TokenType.END)) return TokenType.END;
        }
        return null;
    }

    static TokenType NFA_20(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '(') {
            if (validTypes.contains(TokenType.OPEN_PAREN)) return TokenType.OPEN_PAREN;
        }
        return null;
    }

    static TokenType NFA_21(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(118);
        }
        return null;
    }

    static TokenType NFA_22(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(82);
        }
        return null;
    }

    static TokenType NFA_23(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'u') {
            nextStates.set(162);
        }
        return null;
    }

    static TokenType NFA_24(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(46);
        }
        return null;
    }

    static TokenType NFA_25(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(133);
        }
        return null;
    }

    static TokenType NFA_26(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'c') {
            if (validTypes.contains(TokenType.IINC)) return TokenType.IINC;
        }
        return null;
    }

    static TokenType NFA_27(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'v') {
            nextStates.set(166);
        }
        return null;
    }

    static TokenType NFA_28(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(78);
        }
        return null;
    }

    static TokenType NFA_29(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(95);
        }
        return null;
    }

    static TokenType NFA_30(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'd') {
            nextStates.set(64);
        }
        return null;
    }

    static TokenType NFA_31(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '_') {
            nextStates.set(15);
        }
        return null;
    }

    static TokenType NFA_32(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '3') {
            if (validTypes.contains(TokenType.ISTORE_3)) return TokenType.ISTORE_3;
        }
        return null;
    }

    static TokenType NFA_33(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'm') {
            nextStates.set(175);
        }
        return null;
    }

    static TokenType NFA_34(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '_') {
            nextStates.set(32);
        }
        return null;
    }

    static TokenType NFA_35(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(10);
        }
        return null;
    }

    static TokenType NFA_36(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            if (validTypes.contains(TokenType.IF_ICMPGE)) return TokenType.IF_ICMPGE;
        }
        return null;
    }

    static TokenType NFA_37(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'v') {
            nextStates.set(57);
        }
        return null;
    }

    static TokenType NFA_38(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(114);
        }
        return null;
    }

    static TokenType NFA_39(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '.') {
            if (validTypes.contains(TokenType.DOT)) return TokenType.DOT;
        }
        return null;
    }

    static TokenType NFA_40(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(29);
        }
        return null;
    }

    static TokenType NFA_41(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'c') {
            if (validTypes.contains(TokenType.STATIC)) return TokenType.STATIC;
        }
        return null;
    }

    static TokenType NFA_42(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            nextStates.set(3);
        }
        return null;
    }

    static TokenType NFA_43(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(152);
        }
        return null;
    }

    static TokenType NFA_44(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'c') {
            nextStates.set(99);
        }
        return null;
    }

    static TokenType NFA_45(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(55);
        }
        return null;
    }

    static TokenType NFA_46(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'u') {
            nextStates.set(62);
        }
        return null;
    }

    static TokenType NFA_47(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(116);
        }
        return null;
    }

    static TokenType NFA_48(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(38);
        }
        return null;
    }

    static TokenType NFA_49(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(137);
        }
        return null;
    }

    static TokenType NFA_50(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(51);
        }
        return null;
    }

    static TokenType NFA_51(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            if (validTypes.contains(TokenType.INVOKENONVIRTUAL)) return TokenType.INVOKENONVIRTUAL;
        }
        return null;
    }

    static TokenType NFA_52(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            nextStates.set(23);
        }
        return null;
    }

    static TokenType NFA_53(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '_') {
            nextStates.set(6);
        }
        return null;
    }

    static TokenType NFA_54(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(42);
        }
        return null;
    }

    static TokenType NFA_55(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(155);
        }
        return null;
    }

    static TokenType NFA_56(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(48);
        }
        return null;
    }

    static TokenType NFA_57(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(109);
        }
        return null;
    }

    static TokenType NFA_58(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '>') {
            if (validTypes.contains(TokenType.GREAT)) return TokenType.GREAT;
        }
        return null;
    }

    static TokenType NFA_59(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            nextStates.set(107);
        }
        return null;
    }

    static TokenType NFA_60(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(17);
        }
        return null;
    }

    static TokenType NFA_61(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '\r') {
            if (validTypes.contains(TokenType._TOKEN_3)) return TokenType._TOKEN_3;
        }
        return null;
    }

    static TokenType NFA_62(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'r') {
            nextStates.set(12);
        }
        return null;
    }

    static TokenType NFA_63(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(131);
        }
        return null;
    }

    static TokenType NFA_64(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'd') {
            if (validTypes.contains(TokenType.IADD)) return TokenType.IADD;
        }
        return null;
    }

    static TokenType NFA_65(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'r') {
            nextStates.set(154);
        }
        return null;
    }

    static TokenType NFA_66(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            nextStates.set(22);
        }
        return null;
    }

    static TokenType NFA_67(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(164);
        }
        return null;
    }

    static TokenType NFA_68(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'c') {
            nextStates.set(9);
        }
        return null;
    }

    static TokenType NFA_69(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'd') {
            nextStates.set(160);
        }
        return null;
    }

    static TokenType NFA_70(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'p') {
            nextStates.set(112);
        }
        return null;
    }

    static TokenType NFA_71(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(111);
        }
        return null;
    }

    static TokenType NFA_72(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(40);
        }
        return null;
    }

    static TokenType NFA_73(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'r') {
            nextStates.set(138);
        }
        return null;
    }

    static TokenType NFA_74(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'c') {
            if (validTypes.contains(TokenType.PUBLIC)) return TokenType.PUBLIC;
        }
        return null;
    }

    static TokenType NFA_75(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== ')') {
            if (validTypes.contains(TokenType.CLOSE_PAREN)) return TokenType.CLOSE_PAREN;
        }
        return null;
    }

    static TokenType NFA_76(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'p') {
            if (validTypes.contains(TokenType.ENDLOOP)) return TokenType.ENDLOOP;
        }
        return null;
    }

    static TokenType NFA_77(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'c') {
            nextStates.set(176);
        }
        return null;
    }

    static TokenType NFA_78(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'f') {
            nextStates.set(31);
        }
        return null;
    }

    static TokenType NFA_79(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(86);
        }
        return null;
    }

    static TokenType NFA_80(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'm') {
            nextStates.set(110);
        }
        return null;
    }

    static TokenType NFA_81(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(77);
        }
        return null;
    }

    static TokenType NFA_82(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(21);
        }
        return null;
    }

    static TokenType NFA_83(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '\n') {
            if (validTypes.contains(TokenType._TOKEN_4)) return TokenType._TOKEN_4;
        }
        return null;
    }

    static TokenType NFA_84(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(103);
        }
        return null;
    }

    static TokenType NFA_85(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '_') {
            nextStates.set(16);
        }
        return null;
    }

    static TokenType NFA_86(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            nextStates.set(19);
        }
        return null;
    }

    static TokenType NFA_87(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '0') {
            if (validTypes.contains(TokenType.ALOAD_0)) return TokenType.ALOAD_0;
        }
        return null;
    }

    static TokenType NFA_88(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(56);
        }
        return null;
    }

    static TokenType NFA_89(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(80);
        }
        return null;
    }

    static TokenType NFA_90(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '\t') {
            if (validTypes.contains(TokenType._TOKEN_2)) return TokenType._TOKEN_2;
        }
        return null;
    }

    static TokenType NFA_91(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'u') {
            nextStates.set(50);
        }
        return null;
    }

    static TokenType NFA_92(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'd') {
            nextStates.set(94);
        }
        return null;
    }

    static TokenType NFA_93(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(76);
        }
        return null;
    }

    static TokenType NFA_94(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '_') {
            nextStates.set(167);
        }
        return null;
    }

    static TokenType NFA_95(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(92);
        }
        return null;
    }

    static TokenType NFA_96(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            nextStates.set(7);
        }
        return null;
    }

    static TokenType NFA_97(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(134);
        }
        return null;
    }

    static TokenType NFA_98(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(59);
        }
        return null;
    }

    static TokenType NFA_99(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(47);
        }
        return null;
    }

    static TokenType NFA_100(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(171);
        }
        return null;
    }

    static TokenType NFA_101(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '_') {
            nextStates.set(87);
        }
        return null;
    }

    static TokenType NFA_102(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(119);
        }
        return null;
    }

    static TokenType NFA_103(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            if (validTypes.contains(TokenType.LOCALS)) return TokenType.LOCALS;
        }
        return null;
    }

    static TokenType NFA_104(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'r') {
            if (validTypes.contains(TokenType.SUPER)) return TokenType.SUPER;
        }
        return null;
    }

    static TokenType NFA_105(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(158);
        }
        return null;
    }

    static TokenType NFA_106(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            nextStates.set(125);
        }
        return null;
    }

    static TokenType NFA_107(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'd') {
            nextStates.set(60);
        }
        return null;
    }

    static TokenType NFA_108(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '<') {
            if (validTypes.contains(TokenType.LESS)) return TokenType.LESS;
        }
        return null;
    }

    static TokenType NFA_109(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'r') {
            nextStates.set(146);
        }
        return null;
    }

    static TokenType NFA_110(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(117);
        }
        return null;
    }

    static TokenType NFA_111(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'p') {
            if (validTypes.contains(TokenType.LOOP)) return TokenType.LOOP;
        }
        return null;
    }

    static TokenType NFA_112(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'u') {
            nextStates.set(142);
        }
        return null;
    }

    static TokenType NFA_113(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(74);
        }
        return null;
    }

    static TokenType NFA_114(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'd') {
            nextStates.set(120);
        }
        return null;
    }

    static TokenType NFA_115(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(122);
        }
        return null;
    }

    static TokenType NFA_116(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            nextStates.set(147);
        }
        return null;
    }

    static TokenType NFA_117(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            if (validTypes.contains(TokenType.LIMIT)) return TokenType.LIMIT;
        }
        return null;
    }

    static TokenType NFA_118(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(41);
        }
        return null;
    }

    static TokenType NFA_119(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(69);
        }
        return null;
    }

    static TokenType NFA_120(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '_') {
            nextStates.set(157);
        }
        return null;
    }

    static TokenType NFA_121(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            nextStates.set(106);
        }
        return null;
    }

    static TokenType NFA_122(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(102);
        }
        return null;
    }

    static TokenType NFA_123(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(30);
        }
        return null;
    }

    static TokenType NFA_124(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'h') {
            nextStates.set(35);
        }
        return null;
    }

    static TokenType NFA_125(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(85);
        }
        return null;
    }

    static TokenType NFA_126(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(34);
        }
        return null;
    }

    static TokenType NFA_127(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(53);
        }
        return null;
    }

    static TokenType NFA_128(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(174);
        }
        return null;
    }

    static TokenType NFA_129(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(104);
        }
        return null;
    }

    static TokenType NFA_130(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'I') {
            if (validTypes.contains(TokenType.INT)) return TokenType.INT;
        }
        return null;
    }

    static TokenType NFA_131(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(124);
        }
        return null;
    }

    static TokenType NFA_132(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'g') {
            nextStates.set(36);
        }
        return null;
    }

    static TokenType NFA_133(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(163);
        }
        return null;
    }

    static TokenType NFA_134(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'u') {
            nextStates.set(73);
        }
        return null;
    }

    static TokenType NFA_135(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(24);
        }
        return null;
    }

    static TokenType NFA_136(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== ';') {
            if (validTypes.contains(TokenType.SEMICOLON)) return TokenType.SEMICOLON;
        }
        return null;
    }

    static TokenType NFA_137(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(68);
        }
        return null;
    }

    static TokenType NFA_138(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            if (validTypes.contains(TokenType.IRETURN)) return TokenType.IRETURN;
        }
        return null;
    }

    static TokenType NFA_139(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(156);
        }
        return null;
    }

    static TokenType NFA_140(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'k') {
            nextStates.set(128);
        }
        return null;
    }

    static TokenType NFA_141(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== ':') {
            if (validTypes.contains(TokenType.DOUBLE_DOT)) return TokenType.DOUBLE_DOT;
        }
        return null;
    }

    static TokenType NFA_142(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'b') {
            nextStates.set(149);
        }
        return null;
    }

    static TokenType NFA_143(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(150);
        }
        return null;
    }

    static TokenType NFA_144(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'm') {
            nextStates.set(63);
        }
        return null;
    }

    static TokenType NFA_145(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(14);
        }
        return null;
    }

    static TokenType NFA_146(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(91);
        }
        return null;
    }

    static TokenType NFA_147(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            if (validTypes.contains(TokenType.CLASS)) return TokenType.CLASS;
        }
        return null;
    }

    static TokenType NFA_148(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch>='0'&&ch<='9') {
            nextStates.set(148);
            if (validTypes.contains(TokenType.INTEGER)) return TokenType.INTEGER;
        }
        return null;
    }

    static TokenType NFA_149(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(113);
        }
        return null;
    }

    static TokenType NFA_150(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            nextStates.set(37);
        }
        return null;
    }

    static TokenType NFA_151(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '3') {
            if (validTypes.contains(TokenType.ILOAD_3)) return TokenType.ILOAD_3;
        }
        return null;
    }

    static TokenType NFA_152(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(71);
        }
        return null;
    }

    static TokenType NFA_153(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 't') {
            nextStates.set(8);
        }
        return null;
    }

    static TokenType NFA_154(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'e') {
            nextStates.set(97);
        }
        return null;
    }

    static TokenType NFA_155(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'd') {
            nextStates.set(101);
        }
        return null;
    }

    static TokenType NFA_156(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'r') {
            nextStates.set(126);
        }
        return null;
    }

    static TokenType NFA_157(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '1') {
            if (validTypes.contains(TokenType.ILOAD_1)) return TokenType.ILOAD_1;
        }
        return null;
    }

    static TokenType NFA_158(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'c') {
            nextStates.set(168);
        }
        return null;
    }

    static TokenType NFA_159(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'l') {
            nextStates.set(89);
        }
        return null;
    }

    static TokenType NFA_160(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '_') {
            nextStates.set(151);
        }
        return null;
    }

    static TokenType NFA_161(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(65);
        }
        return null;
    }

    static TokenType NFA_162(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'p') {
            nextStates.set(129);
        }
        return null;
    }

    static TokenType NFA_163(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            nextStates.set(26);
        }
        return null;
    }

    static TokenType NFA_164(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            nextStates.set(27);
        }
        return null;
    }

    static TokenType NFA_165(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(153);
        }
        return null;
    }

    static TokenType NFA_166(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(140);
        }
        return null;
    }

    static TokenType NFA_167(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '2') {
            if (validTypes.contains(TokenType.ILOAD_2)) return TokenType.ILOAD_2;
        }
        return null;
    }

    static TokenType NFA_168(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'k') {
            if (validTypes.contains(TokenType.STACK)) return TokenType.STACK;
        }
        return null;
    }

    static TokenType NFA_169(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '/') {
            if (validTypes.contains(TokenType.SLASH)) return TokenType.SLASH;
        }
        return null;
    }

    static TokenType NFA_170(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'i') {
            nextStates.set(123);
        }
        return null;
    }

    static TokenType NFA_171(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 's') {
            nextStates.set(145);
        }
        return null;
    }

    static TokenType NFA_172(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'a') {
            nextStates.set(18);
        }
        return null;
    }

    static TokenType NFA_173(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'V') {
            if (validTypes.contains(TokenType.VOID)) return TokenType.VOID;
        }
        return null;
    }

    static TokenType NFA_174(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'n') {
            nextStates.set(143);
        }
        return null;
    }

    static TokenType NFA_175(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'p') {
            nextStates.set(132);
        }
        return null;
    }

    static TokenType NFA_176(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'o') {
            nextStates.set(121);
        }
        return null;
    }

    static TokenType NFA_177(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== 'r') {
            nextStates.set(135);
        }
        return null;
    }

    static TokenType NFA_178(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch>='A'&&ch<='Z') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) return TokenType.IDENTIFIER;
        }
        return null;
    }

    static TokenType NFA_179(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch>='a'&&ch<='z') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) return TokenType.IDENTIFIER;
        }
        return null;
    }

    static TokenType NFA_180(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch>='a'&&ch<='z') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) return TokenType.IDENTIFIER;
        }
        return null;
    }

    static TokenType NFA_181(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch== '_') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) return TokenType.IDENTIFIER;
        }
        return null;
    }

    static TokenType NFA_182(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch>='0'&&ch<='9') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) return TokenType.IDENTIFIER;
        }
        return null;
    }

    static TokenType NFA_183(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
        if (ch>='A'&&ch<='Z') {
            nextStates.set(2);
            if (validTypes.contains(TokenType.IDENTIFIER)) return TokenType.IDENTIFIER;
        }
        return null;
    }

    static private void NFA_FUNCTIONS_DEFAULT_init() {
        NfaFunction[] functions= new NfaFunction[184];
        functions[0]= JasminParserNfaData::NFA_COMPOSITE_0;
        functions[1]= JasminParserNfaData::NFA_COMPOSITE_1;
        functions[2]= JasminParserNfaData::NFA_COMPOSITE_2;
        functions[3]= JasminParserNfaData::NFA_3;
        functions[4]= JasminParserNfaData::NFA_4;
        functions[5]= JasminParserNfaData::NFA_5;
        functions[6]= JasminParserNfaData::NFA_6;
        functions[7]= JasminParserNfaData::NFA_7;
        functions[8]= JasminParserNfaData::NFA_8;
        functions[9]= JasminParserNfaData::NFA_9;
        functions[10]= JasminParserNfaData::NFA_10;
        functions[11]= JasminParserNfaData::NFA_11;
        functions[12]= JasminParserNfaData::NFA_12;
        functions[13]= JasminParserNfaData::NFA_13;
        functions[14]= JasminParserNfaData::NFA_14;
        functions[15]= JasminParserNfaData::NFA_15;
        functions[16]= JasminParserNfaData::NFA_16;
        functions[17]= JasminParserNfaData::NFA_17;
        functions[18]= JasminParserNfaData::NFA_18;
        functions[19]= JasminParserNfaData::NFA_19;
        functions[20]= JasminParserNfaData::NFA_20;
        functions[21]= JasminParserNfaData::NFA_21;
        functions[22]= JasminParserNfaData::NFA_22;
        functions[23]= JasminParserNfaData::NFA_23;
        functions[24]= JasminParserNfaData::NFA_24;
        functions[25]= JasminParserNfaData::NFA_25;
        functions[26]= JasminParserNfaData::NFA_26;
        functions[27]= JasminParserNfaData::NFA_27;
        functions[28]= JasminParserNfaData::NFA_28;
        functions[29]= JasminParserNfaData::NFA_29;
        functions[30]= JasminParserNfaData::NFA_30;
        functions[31]= JasminParserNfaData::NFA_31;
        functions[32]= JasminParserNfaData::NFA_32;
        functions[33]= JasminParserNfaData::NFA_33;
        functions[34]= JasminParserNfaData::NFA_34;
        functions[35]= JasminParserNfaData::NFA_35;
        functions[36]= JasminParserNfaData::NFA_36;
        functions[37]= JasminParserNfaData::NFA_37;
        functions[38]= JasminParserNfaData::NFA_38;
        functions[39]= JasminParserNfaData::NFA_39;
        functions[40]= JasminParserNfaData::NFA_40;
        functions[41]= JasminParserNfaData::NFA_41;
        functions[42]= JasminParserNfaData::NFA_42;
        functions[43]= JasminParserNfaData::NFA_43;
        functions[44]= JasminParserNfaData::NFA_44;
        functions[45]= JasminParserNfaData::NFA_45;
        functions[46]= JasminParserNfaData::NFA_46;
        functions[47]= JasminParserNfaData::NFA_47;
        functions[48]= JasminParserNfaData::NFA_48;
        functions[49]= JasminParserNfaData::NFA_49;
        functions[50]= JasminParserNfaData::NFA_50;
        functions[51]= JasminParserNfaData::NFA_51;
        functions[52]= JasminParserNfaData::NFA_52;
        functions[53]= JasminParserNfaData::NFA_53;
        functions[54]= JasminParserNfaData::NFA_54;
        functions[55]= JasminParserNfaData::NFA_55;
        functions[56]= JasminParserNfaData::NFA_56;
        functions[57]= JasminParserNfaData::NFA_57;
        functions[58]= JasminParserNfaData::NFA_58;
        functions[59]= JasminParserNfaData::NFA_59;
        functions[60]= JasminParserNfaData::NFA_60;
        functions[61]= JasminParserNfaData::NFA_61;
        functions[62]= JasminParserNfaData::NFA_62;
        functions[63]= JasminParserNfaData::NFA_63;
        functions[64]= JasminParserNfaData::NFA_64;
        functions[65]= JasminParserNfaData::NFA_65;
        functions[66]= JasminParserNfaData::NFA_66;
        functions[67]= JasminParserNfaData::NFA_67;
        functions[68]= JasminParserNfaData::NFA_68;
        functions[69]= JasminParserNfaData::NFA_69;
        functions[70]= JasminParserNfaData::NFA_70;
        functions[71]= JasminParserNfaData::NFA_71;
        functions[72]= JasminParserNfaData::NFA_72;
        functions[73]= JasminParserNfaData::NFA_73;
        functions[74]= JasminParserNfaData::NFA_74;
        functions[75]= JasminParserNfaData::NFA_75;
        functions[76]= JasminParserNfaData::NFA_76;
        functions[77]= JasminParserNfaData::NFA_77;
        functions[78]= JasminParserNfaData::NFA_78;
        functions[79]= JasminParserNfaData::NFA_79;
        functions[80]= JasminParserNfaData::NFA_80;
        functions[81]= JasminParserNfaData::NFA_81;
        functions[82]= JasminParserNfaData::NFA_82;
        functions[83]= JasminParserNfaData::NFA_83;
        functions[84]= JasminParserNfaData::NFA_84;
        functions[85]= JasminParserNfaData::NFA_85;
        functions[86]= JasminParserNfaData::NFA_86;
        functions[87]= JasminParserNfaData::NFA_87;
        functions[88]= JasminParserNfaData::NFA_88;
        functions[89]= JasminParserNfaData::NFA_89;
        functions[90]= JasminParserNfaData::NFA_90;
        functions[91]= JasminParserNfaData::NFA_91;
        functions[92]= JasminParserNfaData::NFA_92;
        functions[93]= JasminParserNfaData::NFA_93;
        functions[94]= JasminParserNfaData::NFA_94;
        functions[95]= JasminParserNfaData::NFA_95;
        functions[96]= JasminParserNfaData::NFA_96;
        functions[97]= JasminParserNfaData::NFA_97;
        functions[98]= JasminParserNfaData::NFA_98;
        functions[99]= JasminParserNfaData::NFA_99;
        functions[100]= JasminParserNfaData::NFA_100;
        functions[101]= JasminParserNfaData::NFA_101;
        functions[102]= JasminParserNfaData::NFA_102;
        functions[103]= JasminParserNfaData::NFA_103;
        functions[104]= JasminParserNfaData::NFA_104;
        functions[105]= JasminParserNfaData::NFA_105;
        functions[106]= JasminParserNfaData::NFA_106;
        functions[107]= JasminParserNfaData::NFA_107;
        functions[108]= JasminParserNfaData::NFA_108;
        functions[109]= JasminParserNfaData::NFA_109;
        functions[110]= JasminParserNfaData::NFA_110;
        functions[111]= JasminParserNfaData::NFA_111;
        functions[112]= JasminParserNfaData::NFA_112;
        functions[113]= JasminParserNfaData::NFA_113;
        functions[114]= JasminParserNfaData::NFA_114;
        functions[115]= JasminParserNfaData::NFA_115;
        functions[116]= JasminParserNfaData::NFA_116;
        functions[117]= JasminParserNfaData::NFA_117;
        functions[118]= JasminParserNfaData::NFA_118;
        functions[119]= JasminParserNfaData::NFA_119;
        functions[120]= JasminParserNfaData::NFA_120;
        functions[121]= JasminParserNfaData::NFA_121;
        functions[122]= JasminParserNfaData::NFA_122;
        functions[123]= JasminParserNfaData::NFA_123;
        functions[124]= JasminParserNfaData::NFA_124;
        functions[125]= JasminParserNfaData::NFA_125;
        functions[126]= JasminParserNfaData::NFA_126;
        functions[127]= JasminParserNfaData::NFA_127;
        functions[128]= JasminParserNfaData::NFA_128;
        functions[129]= JasminParserNfaData::NFA_129;
        functions[130]= JasminParserNfaData::NFA_130;
        functions[131]= JasminParserNfaData::NFA_131;
        functions[132]= JasminParserNfaData::NFA_132;
        functions[133]= JasminParserNfaData::NFA_133;
        functions[134]= JasminParserNfaData::NFA_134;
        functions[135]= JasminParserNfaData::NFA_135;
        functions[136]= JasminParserNfaData::NFA_136;
        functions[137]= JasminParserNfaData::NFA_137;
        functions[138]= JasminParserNfaData::NFA_138;
        functions[139]= JasminParserNfaData::NFA_139;
        functions[140]= JasminParserNfaData::NFA_140;
        functions[141]= JasminParserNfaData::NFA_141;
        functions[142]= JasminParserNfaData::NFA_142;
        functions[143]= JasminParserNfaData::NFA_143;
        functions[144]= JasminParserNfaData::NFA_144;
        functions[145]= JasminParserNfaData::NFA_145;
        functions[146]= JasminParserNfaData::NFA_146;
        functions[147]= JasminParserNfaData::NFA_147;
        functions[148]= JasminParserNfaData::NFA_148;
        functions[149]= JasminParserNfaData::NFA_149;
        functions[150]= JasminParserNfaData::NFA_150;
        functions[151]= JasminParserNfaData::NFA_151;
        functions[152]= JasminParserNfaData::NFA_152;
        functions[153]= JasminParserNfaData::NFA_153;
        functions[154]= JasminParserNfaData::NFA_154;
        functions[155]= JasminParserNfaData::NFA_155;
        functions[156]= JasminParserNfaData::NFA_156;
        functions[157]= JasminParserNfaData::NFA_157;
        functions[158]= JasminParserNfaData::NFA_158;
        functions[159]= JasminParserNfaData::NFA_159;
        functions[160]= JasminParserNfaData::NFA_160;
        functions[161]= JasminParserNfaData::NFA_161;
        functions[162]= JasminParserNfaData::NFA_162;
        functions[163]= JasminParserNfaData::NFA_163;
        functions[164]= JasminParserNfaData::NFA_164;
        functions[165]= JasminParserNfaData::NFA_165;
        functions[166]= JasminParserNfaData::NFA_166;
        functions[167]= JasminParserNfaData::NFA_167;
        functions[168]= JasminParserNfaData::NFA_168;
        functions[169]= JasminParserNfaData::NFA_169;
        functions[170]= JasminParserNfaData::NFA_170;
        functions[171]= JasminParserNfaData::NFA_171;
        functions[172]= JasminParserNfaData::NFA_172;
        functions[173]= JasminParserNfaData::NFA_173;
        functions[174]= JasminParserNfaData::NFA_174;
        functions[175]= JasminParserNfaData::NFA_175;
        functions[176]= JasminParserNfaData::NFA_176;
        functions[177]= JasminParserNfaData::NFA_177;
        functions[178]= JasminParserNfaData::NFA_178;
        functions[179]= JasminParserNfaData::NFA_179;
        functions[180]= JasminParserNfaData::NFA_180;
        functions[181]= JasminParserNfaData::NFA_181;
        functions[182]= JasminParserNfaData::NFA_182;
        functions[183]= JasminParserNfaData::NFA_183;
        nfaFunctions= functions;
    }

}
