/* Generated by: JavaCC 21 Parser Generator. JasminParser.java */
import java.util.Arrays;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Map;
import java.util.concurrent.CancellationException;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.charset.Charset;
@SuppressWarnings("unused")
public class JasminParser implements JasminParserConstants {
    static public void main(String[] args) {
        if (args.length== 0) {
            System.out.println("Usage: java JasminParser <input>");
            System.exit(-1);
        }
        String input= "";
        for (String arg : args) input+=arg;
        JasminParser parser= new JasminParser(input);
        parser.Start();
    }

    static final int UNLIMITED= Integer.MAX_VALUE;
    // The last token successfully "consumed"
    Token lastConsumedToken;
    private TokenType nextTokenType;
    private Token currentLookaheadToken;
    private boolean scanToEnd;
    private String currentlyParsedProduction, currentLookaheadProduction;
    private boolean cancelled;
    public void cancel() {
        cancelled= true;
    }

    public boolean isCancelled() {
        return cancelled;
    }

    /** Generated Lexer. */
    public JasminParserLexer token_source;
    public void setInputSource(String inputSource) {
        token_source.setInputSource(inputSource);
    }

    String getInputSource() {
        return token_source.getInputSource();
    }

    //=================================
    // Generated constructors
    //=================================
    public JasminParser(String inputSource, CharSequence content) {
        this(new JasminParserLexer(inputSource, content));
    }

    public JasminParser(CharSequence content) {
        this("input", content);
    }

    /**
   * @param inputSource just the name of the input source (typically the filename) that 
   * will be used in error messages and so on.
   * @param path The location (typically the filename) from which to get the input to parse
   */
    public JasminParser(String inputSource, Path path) throws IOException {
        this(inputSource, JasminParserConstants.stringFromBytes(Files.readAllBytes(path)));
    }

    public JasminParser(String inputSource, Path path, Charset charset) throws IOException {
        this(inputSource, JasminParserConstants.stringFromBytes(Files.readAllBytes(path), charset));
    }

    /**
   * @param path The location (typically the filename) from which to get the input to parse
   */
    public JasminParser(Path path) throws IOException {
        this(path.toString(), path);
    }

    /**
   * @Deprecated Use the constructor that takes a #java.nio.files.Path or just 
   * a String (i.e. CharSequence) directly.
   */
    public JasminParser(java.io.InputStream stream) {
        this(new InputStreamReader(stream));
    }

    /**
   * @Deprecated Use the constructor that takes a #java.nio.files.Path or just 
   * a String (i.e. CharSequence) directly.
   */
    public JasminParser(Reader reader) {
        this(new JasminParserLexer("input", reader));
    }

    /** Constructor with user supplied Lexer. */
    public JasminParser(JasminParserLexer lexer) {
        token_source= lexer;
        lastConsumedToken= lexer.DUMMY_START_TOKEN;
        lastConsumedToken.setTokenSource(lexer);
    }

    // If the next token is cached, it returns that
    // Otherwise, it goes to the token_source, i.e. the Lexer.
    final private Token nextToken(final Token tok) {
        Token result= token_source.getNextToken(tok);
        while (result.isUnparsed()) {
            result= token_source.getNextToken(result);
        }
        nextTokenType= null;
        return result;
    }

    /**
   * @return the next Token off the stream. This is the same as #getToken(1)
   */
    final public Token getNextToken() {
        return getToken(1);
    }

    /**
 * @param index how many tokens to look ahead
 * @return the specific regular (i.e. parsed) Token index ahead/behind in the stream. 
 * If we are in a lookahead, it looks ahead from the currentLookaheadToken
 * Otherwise, it is the lastConsumedToken. If you pass in a negative
 * number it goes backward.
 */
    final public Token getToken(final int index) {
        Token t= currentLookaheadToken== null?lastConsumedToken:
        currentLookaheadToken;
        for (int i= 0; i<index; i++) {
            t= nextToken(t);
        }
        for (int i= 0; i> index; i--) {
            t= t.getPrevious();
            if (t== null) break;
        }
        return t;
    }

    private final TokenType nextTokenType() {
        if (nextTokenType== null) {
            nextTokenType= nextToken(lastConsumedToken).getType();
        }
        return nextTokenType;
    }

    boolean activateTokenTypes(TokenType...types) {
        boolean result= false;
        for (TokenType tt : types) {
            result|=token_source.activeTokenTypes.add(tt);
        }
        token_source.reset(getToken(0));
        nextTokenType= null;
        return result;
    }

    boolean deactivateTokenTypes(TokenType...types) {
        boolean result= false;
        for (TokenType tt : types) {
            result|=token_source.activeTokenTypes.remove(tt);
        }
        token_source.reset(getToken(0));
        nextTokenType= null;
        return result;
    }

    private static HashMap<TokenType[], EnumSet<TokenType> > enumSetCache= new HashMap<> ();
    private static EnumSet<TokenType> tokenTypeSet(TokenType first, TokenType...rest) {
        TokenType[] key= new TokenType[1+rest.length];
        key[0]= first;
        if (rest.length> 0) {
            System.arraycopy(rest, 0, key, 1, rest.length);
        }
        Arrays.sort(key);
        if (enumSetCache.containsKey(key)) {
            return enumSetCache.get(key);
        }
        EnumSet<TokenType> result= (rest.length== 0)?EnumSet.of(first):
        EnumSet.of(first, rest);
        enumSetCache.put(key, result);
        return result;
    }

    // JasminParser.jj:60:1
    final public void Start() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Start";
        Start Start1= null;
        if (buildTree) {
            Start1= new Start();
            openNodeScope(Start1);
        }
        ParseException parseException1= null;
        int callStackSize2= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JasminParser.jj:60:8
            consumeToken(TokenType.DOT);
            // Code for NonTerminal specified at:
            // JasminParser.jj:60:14
            pushOntoCallStack("Start", "JasminParser.jj", 1505);
            try {
                ClassDeclaration();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrOne specified at:
            // JasminParser.jj:60:31
            if (nextTokenType()== TokenType.DOT) {
                // Code for NonTerminal specified at:
                // JasminParser.jj:60:32
                pushOntoCallStack("Start", "JasminParser.jj", 1523);
                try {
                    SuperDeclaration();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException1= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2);
            if (Start1!=null) {
                if (parseException1== null) {
                    closeNodeScope(Start1, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JasminParser.jj:63:1
    final public void ClassDeclaration() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ClassDeclaration";
        ClassDeclaration ClassDeclaration2= null;
        if (buildTree) {
            ClassDeclaration2= new ClassDeclaration();
            openNodeScope(ClassDeclaration2);
        }
        ParseException parseException19= null;
        int callStackSize20= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JasminParser.jj:63:19
            consumeToken(TokenType.CLASS);
            // Code for RegexpRef specified at:
            // JasminParser.jj:63:27
            consumeToken(TokenType.PUBLIC);
            // Code for RegexpRef specified at:
            // JasminParser.jj:63:36
            consumeToken(TokenType.IDENTIFIER);
        }
        catch(ParseException e) {
            parseException19= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize20);
            if (ClassDeclaration2!=null) {
                if (parseException19== null) {
                    closeNodeScope(ClassDeclaration2, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JasminParser.jj:65:1
    final public void SuperDeclaration() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "SuperDeclaration";
        SuperDeclaration SuperDeclaration3= null;
        if (buildTree) {
            SuperDeclaration3= new SuperDeclaration();
            openNodeScope(SuperDeclaration3);
        }
        ParseException parseException31= null;
        int callStackSize32= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JasminParser.jj:65:19
            consumeToken(TokenType.DOT);
            // Code for RegexpRef specified at:
            // JasminParser.jj:65:25
            consumeToken(TokenType.SUPER);
            // Code for ZeroOrMore specified at:
            // JasminParser.jj:65:33
            while (true) {
                if (!(nextTokenType()== TokenType.IDENTIFIER)) break;
                // Code for RegexpRef specified at:
                // JasminParser.jj:65:34
                consumeToken(TokenType.IDENTIFIER);
                // Code for RegexpRef specified at:
                // JasminParser.jj:65:47
                consumeToken(TokenType.SLASH);
            }
            // Code for NonTerminal specified at:
            // JasminParser.jj:65:58
            pushOntoCallStack("SuperDeclaration", "JasminParser.jj", 1652);
            try {
                MethodDeclaration();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpRef specified at:
            // JasminParser.jj:65:77
            consumeToken(TokenType.OPEN_PAREN);
            // Code for RegexpRef specified at:
            // JasminParser.jj:65:90
            consumeToken(TokenType.CLOSE_PAREN);
        }
        catch(ParseException e) {
            parseException31= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize32);
            if (SuperDeclaration3!=null) {
                if (parseException31== null) {
                    closeNodeScope(SuperDeclaration3, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JasminParser.jj:67:1
    final public void Instruction() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Instruction";
        Instruction Instruction4= null;
        if (buildTree) {
            Instruction4= new Instruction();
            openNodeScope(Instruction4);
        }
        ParseException parseException65= null;
        int callStackSize66= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            if (nextTokenType()== TokenType.ALOAD_0) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:68:6
                consumeToken(TokenType.ALOAD_0);
            }
            else if (nextTokenType()== TokenType.ICONST_0) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:69:5
                consumeToken(TokenType.ICONST_0);
            }
            else if (nextTokenType()== TokenType.ISTORE_2) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:70:5
                consumeToken(TokenType.ISTORE_2);
            }
            else if (nextTokenType()== TokenType.ISTORE_3) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:71:5
                consumeToken(TokenType.ISTORE_3);
            }
            else if (nextTokenType()== TokenType.ILOAD_1) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:72:5
                consumeToken(TokenType.ILOAD_1);
            }
            else if (nextTokenType()== TokenType.ILOAD_2) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:73:5
                consumeToken(TokenType.ILOAD_2);
            }
            else if (nextTokenType()== TokenType.ILOAD_3) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:74:5
                consumeToken(TokenType.ILOAD_3);
            }
            else if (nextTokenType()== TokenType.IF_ICMPGE) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:75:5
                consumeToken(TokenType.IF_ICMPGE);
            }
            else if (nextTokenType()== TokenType.IADD) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:76:5
                consumeToken(TokenType.IADD);
            }
            else if (nextTokenType()== TokenType.IINC) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:77:5
                consumeToken(TokenType.IINC);
                // Code for ZeroOrOne specified at:
                // JasminParser.jj:77:12
                if (nextTokenType()== TokenType.INTEGER) {
                    // Code for RegexpRef specified at:
                    // JasminParser.jj:77:13
                    consumeToken(TokenType.INTEGER);
                }
                // Code for ZeroOrOne specified at:
                // JasminParser.jj:77:25
                if (nextTokenType()== TokenType.INTEGER) {
                    // Code for RegexpRef specified at:
                    // JasminParser.jj:77:26
                    consumeToken(TokenType.INTEGER);
                }
            }
            else if (nextTokenType()== TokenType.ALOAD_0) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:78:5
                consumeToken(TokenType.ALOAD_0);
            }
            else if (nextTokenType()== TokenType.RETURN) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:79:5
                consumeToken(TokenType.RETURN);
            }
            else if (nextTokenType()== TokenType.IRETURN) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:80:5
                consumeToken(TokenType.IRETURN);
            }
            else if (nextTokenType()== TokenType.DOT) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:81:5
                consumeToken(TokenType.DOT);
                // Code for RegexpRef specified at:
                // JasminParser.jj:81:11
                consumeToken(TokenType.LIMIT);
                // Code for RegexpRef specified at:
                // JasminParser.jj:81:19
                consumeToken(TokenType.LOCALS);
                // Code for ZeroOrOne specified at:
                // JasminParser.jj:81:28
                if (nextTokenType()== TokenType.INTEGER) {
                    // Code for RegexpRef specified at:
                    // JasminParser.jj:81:29
                    consumeToken(TokenType.INTEGER);
                }
            }
            else if (nextTokenType()== TokenType.DOT) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:82:5
                consumeToken(TokenType.DOT);
                // Code for RegexpRef specified at:
                // JasminParser.jj:82:11
                consumeToken(TokenType.LIMIT);
                // Code for RegexpRef specified at:
                // JasminParser.jj:82:19
                consumeToken(TokenType.STACK);
                // Code for ZeroOrOne specified at:
                // JasminParser.jj:82:27
                if (nextTokenType()== TokenType.INTEGER) {
                    // Code for RegexpRef specified at:
                    // JasminParser.jj:82:28
                    consumeToken(TokenType.INTEGER);
                }
            }
            else if (nextTokenType()== TokenType.INVOKENONVIRTUAL) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:83:5
                consumeToken(TokenType.INVOKENONVIRTUAL);
                // Code for ZeroOrOne specified at:
                // JasminParser.jj:83:24
                if (nextTokenType()== TokenType.IDENTIFIER) {
                    // Code for NonTerminal specified at:
                    // JasminParser.jj:83:25
                    pushOntoCallStack("Instruction", "JasminParser.jj", 2054);
                    try {
                        Path1();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
            else  {
                pushOntoCallStack("Instruction", "JasminParser.jj", 1719);
                throw new ParseException(this, first_set$JasminParser_jj$68$6, parsingStack);
            }
            // Code for ZeroOrOne specified at:
            // JasminParser.jj:83:35
            if (nextTokenType()== TokenType.IDENTIFIER) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:83:36
                consumeToken(TokenType.IDENTIFIER);
            }
            // Code for ZeroOrOne specified at:
            // JasminParser.jj:83:51
            if (nextTokenType()== TokenType.IDENTIFIER) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:83:52
                consumeToken(TokenType.IDENTIFIER);
            }
        }
        catch(ParseException e) {
            parseException65= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize66);
            if (Instruction4!=null) {
                if (parseException65== null) {
                    closeNodeScope(Instruction4, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JasminParser.jj:86:1
    final public void Label() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Label";
        Label Label5= null;
        if (buildTree) {
            Label5= new Label();
            openNodeScope(Label5);
        }
        ParseException parseException243= null;
        int callStackSize244= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JasminParser.jj:87:5
            consumeToken(TokenType.IDENTIFIER);
            // Code for RegexpRef specified at:
            // JasminParser.jj:87:18
            consumeToken(TokenType.DOUBLE_DOT);
        }
        catch(ParseException e) {
            parseException243= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize244);
            if (Label5!=null) {
                if (parseException243== null) {
                    closeNodeScope(Label5, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JasminParser.jj:89:1
    final public void Path1() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Path1";
        Path1 Path16= null;
        if (buildTree) {
            Path16= new Path1();
            openNodeScope(Path16);
        }
        ParseException parseException252= null;
        int callStackSize253= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JasminParser.jj:90:5
            consumeToken(TokenType.IDENTIFIER);
            // Code for RegexpRef specified at:
            // JasminParser.jj:90:18
            consumeToken(TokenType.SLASH);
            if (nextTokenType()== TokenType.IDENTIFIER) {
                // Code for NonTerminal specified at:
                // JasminParser.jj:90:28
                pushOntoCallStack("Path1", "JasminParser.jj", 2172);
                try {
                    Path1();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== TokenType.LESS||nextTokenType== TokenType.IDENTIFIER) {
                // Code for NonTerminal specified at:
                // JasminParser.jj:90:38
                pushOntoCallStack("Path1", "JasminParser.jj", 2182);
                try {
                    MethodName();
                }
                finally {
                    popCallStack();
                }
                // Code for NonTerminal specified at:
                // JasminParser.jj:90:51
                pushOntoCallStack("Path1", "JasminParser.jj", 2195);
                try {
                    MethodArguments();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("Path1", "JasminParser.jj", 2171);
                throw new ParseException(this, first_set$JasminParser_jj$90$27, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException252= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize253);
            if (Path16!=null) {
                if (parseException252== null) {
                    closeNodeScope(Path16, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JasminParser.jj:93:1
    final public void MethodDeclaration() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MethodDeclaration";
        MethodDeclaration MethodDeclaration7= null;
        if (buildTree) {
            MethodDeclaration7= new MethodDeclaration();
            openNodeScope(MethodDeclaration7);
        }
        ParseException parseException292= null;
        int callStackSize293= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JasminParser.jj:94:5
            consumeToken(TokenType.DOT);
            // Code for NonTerminal specified at:
            // JasminParser.jj:94:12
            pushOntoCallStack("MethodDeclaration", "JasminParser.jj", 2247);
            try {
                StartMethod();
            }
            finally {
                popCallStack();
            }
            // Code for NonTerminal specified at:
            // JasminParser.jj:94:27
            pushOntoCallStack("MethodDeclaration", "JasminParser.jj", 2262);
            try {
                MethodName();
            }
            finally {
                popCallStack();
            }
            // Code for NonTerminal specified at:
            // JasminParser.jj:94:40
            pushOntoCallStack("MethodDeclaration", "JasminParser.jj", 2275);
            try {
                MethodArguments();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at:
            // JasminParser.jj:94:57
            while (true) {
                if (!(first_set$JasminParser_jj$94$58.contains(nextTokenType()))) break;
                // Code for NonTerminal specified at:
                // JasminParser.jj:94:58
                pushOntoCallStack("MethodDeclaration", "JasminParser.jj", 2293);
                try {
                    MethodBody();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for NonTerminal specified at:
            // JasminParser.jj:95:5
            pushOntoCallStack("MethodDeclaration", "JasminParser.jj", 2310);
            try {
                MethodFinal();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException292= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize293);
            if (MethodDeclaration7!=null) {
                if (parseException292== null) {
                    closeNodeScope(MethodDeclaration7, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JasminParser.jj:97:1
    final public void StartMethod() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "StartMethod";
        StartMethod StartMethod8= null;
        if (buildTree) {
            StartMethod8= new StartMethod();
            openNodeScope(StartMethod8);
        }
        ParseException parseException331= null;
        int callStackSize332= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JasminParser.jj:98:5
            consumeToken(TokenType.METHOD);
            // Code for RegexpRef specified at:
            // JasminParser.jj:98:14
            consumeToken(TokenType.PUBLIC);
            // Code for ZeroOrOne specified at:
            // JasminParser.jj:98:23
            if (nextTokenType()== TokenType.STATIC) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:98:24
                consumeToken(TokenType.STATIC);
            }
        }
        catch(ParseException e) {
            parseException331= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize332);
            if (StartMethod8!=null) {
                if (parseException331== null) {
                    closeNodeScope(StartMethod8, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JasminParser.jj:100:1
    final public void MethodName() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MethodName";
        MethodName MethodName9= null;
        if (buildTree) {
            MethodName9= new MethodName();
            openNodeScope(MethodName9);
        }
        ParseException parseException349= null;
        int callStackSize350= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            if (nextTokenType()== TokenType.LESS) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:101:6
                consumeToken(TokenType.LESS);
                // Code for RegexpRef specified at:
                // JasminParser.jj:101:13
                consumeToken(TokenType.IDENTIFIER);
                // Code for RegexpRef specified at:
                // JasminParser.jj:101:26
                consumeToken(TokenType.GREAT);
            }
            else if (nextTokenType()== TokenType.IDENTIFIER) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:102:5
                consumeToken(TokenType.IDENTIFIER);
            }
            else  {
                pushOntoCallStack("MethodName", "JasminParser.jj", 2391);
                throw new ParseException(this, first_set$JasminParser_jj$101$6, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException349= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize350);
            if (MethodName9!=null) {
                if (parseException349== null) {
                    closeNodeScope(MethodName9, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JasminParser.jj:104:1
    final public void MethodArguments() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MethodArguments";
        MethodArguments MethodArguments10= null;
        if (buildTree) {
            MethodArguments10= new MethodArguments();
            openNodeScope(MethodArguments10);
        }
        ParseException parseException374= null;
        int callStackSize375= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JasminParser.jj:105:5
            consumeToken(TokenType.OPEN_PAREN);
            // Code for ZeroOrOne specified at:
            // JasminParser.jj:105:18
            // Code for ExpansionChoice specified at:
            // JasminParser.jj:105:19
            if (nextTokenType()== TokenType.INT) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:105:19
                consumeToken(TokenType.INT);
            }
            else if (nextTokenType()== TokenType.VOID) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:105:27
                consumeToken(TokenType.VOID);
            }
            // Code for RegexpRef specified at:
            // JasminParser.jj:105:36
            consumeToken(TokenType.CLOSE_PAREN);
            // Code for ZeroOrOne specified at:
            // JasminParser.jj:105:50
            // Code for ExpansionChoice specified at:
            // JasminParser.jj:105:51
            if (nextTokenType()== TokenType.INT) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:105:51
                consumeToken(TokenType.INT);
            }
            else if (nextTokenType()== TokenType.VOID) {
                // Code for RegexpRef specified at:
                // JasminParser.jj:105:59
                consumeToken(TokenType.VOID);
            }
        }
        catch(ParseException e) {
            parseException374= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize375);
            if (MethodArguments10!=null) {
                if (parseException374== null) {
                    closeNodeScope(MethodArguments10, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JasminParser.jj:108:1
    final public void MethodBody() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MethodBody";
        MethodBody MethodBody11= null;
        if (buildTree) {
            MethodBody11= new MethodBody();
            openNodeScope(MethodBody11);
        }
        ParseException parseException419= null;
        int callStackSize420= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            if (first_set$JasminParser_jj$109$6.contains(nextTokenType())) {
                // Code for NonTerminal specified at:
                // JasminParser.jj:109:6
                pushOntoCallStack("MethodBody", "JasminParser.jj", 2545);
                try {
                    Instruction();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== TokenType.IDENTIFIER) {
                // Code for NonTerminal specified at:
                // JasminParser.jj:109:20
                pushOntoCallStack("MethodBody", "JasminParser.jj", 2559);
                try {
                    Label();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("MethodBody", "JasminParser.jj", 2545);
                throw new ParseException(this, first_set$JasminParser_jj$109$6$, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException419= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize420);
            if (MethodBody11!=null) {
                if (parseException419== null) {
                    closeNodeScope(MethodBody11, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // JasminParser.jj:111:1
    final public void MethodFinal() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MethodFinal";
        MethodFinal MethodFinal12= null;
        if (buildTree) {
            MethodFinal12= new MethodFinal();
            openNodeScope(MethodFinal12);
        }
        ParseException parseException438= null;
        int callStackSize439= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // JasminParser.jj:112:5
            consumeToken(TokenType.DOT);
            // Code for RegexpRef specified at:
            // JasminParser.jj:112:11
            consumeToken(TokenType.END);
            // Code for RegexpRef specified at:
            // JasminParser.jj:112:17
            consumeToken(TokenType.METHOD);
        }
        catch(ParseException e) {
            parseException438= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize439);
            if (MethodFinal12!=null) {
                if (parseException438== null) {
                    closeNodeScope(MethodFinal12, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> first_set$JasminParser_jj$68$6= first_set$JasminParser_jj$68$6_init();
    static private EnumSet<TokenType> first_set$JasminParser_jj$68$6_init() {
        return tokenTypeSet(TokenType.DOT, TokenType.ICONST_0, TokenType.ISTORE_2, TokenType.ISTORE_3, TokenType.ILOAD_1, TokenType.ILOAD_2, TokenType.ILOAD_3, TokenType.IF_ICMPGE, TokenType.IADD, TokenType.IINC, TokenType.IRETURN, TokenType.ALOAD_0, TokenType.INVOKENONVIRTUAL, TokenType.RETURN);
    }

    static private final EnumSet<TokenType> first_set$JasminParser_jj$90$27= tokenTypeSet(TokenType.LESS, TokenType.IDENTIFIER);
    static private final EnumSet<TokenType> first_set$JasminParser_jj$94$58= first_set$JasminParser_jj$94$58_init();
    static private EnumSet<TokenType> first_set$JasminParser_jj$94$58_init() {
        return tokenTypeSet(TokenType.DOT, TokenType.ICONST_0, TokenType.ISTORE_2, TokenType.ISTORE_3, TokenType.ILOAD_1, TokenType.ILOAD_2, TokenType.ILOAD_3, TokenType.IF_ICMPGE, TokenType.IADD, TokenType.IINC, TokenType.IRETURN, TokenType.ALOAD_0, TokenType.INVOKENONVIRTUAL, TokenType.RETURN, TokenType.IDENTIFIER);
    }

    static private final EnumSet<TokenType> first_set$JasminParser_jj$101$6= tokenTypeSet(TokenType.LESS, TokenType.IDENTIFIER);
    static private final EnumSet<TokenType> first_set$JasminParser_jj$109$6$= first_set$JasminParser_jj$109$6$_init();
    static private EnumSet<TokenType> first_set$JasminParser_jj$109$6$_init() {
        return tokenTypeSet(TokenType.DOT, TokenType.ICONST_0, TokenType.ISTORE_2, TokenType.ISTORE_3, TokenType.ILOAD_1, TokenType.ILOAD_2, TokenType.ILOAD_3, TokenType.IF_ICMPGE, TokenType.IADD, TokenType.IINC, TokenType.IRETURN, TokenType.ALOAD_0, TokenType.INVOKENONVIRTUAL, TokenType.RETURN, TokenType.IDENTIFIER);
    }

    static private final EnumSet<TokenType> first_set$JasminParser_jj$109$6= first_set$JasminParser_jj$109$6_init();
    static private EnumSet<TokenType> first_set$JasminParser_jj$109$6_init() {
        return tokenTypeSet(TokenType.DOT, TokenType.ICONST_0, TokenType.ISTORE_2, TokenType.ISTORE_3, TokenType.ILOAD_1, TokenType.ILOAD_2, TokenType.ILOAD_3, TokenType.IF_ICMPGE, TokenType.IADD, TokenType.IINC, TokenType.IRETURN, TokenType.ALOAD_0, TokenType.INVOKENONVIRTUAL, TokenType.RETURN);
    }

    ArrayList<NonTerminalCall> parsingStack= new ArrayList<> ();
    private ArrayList<NonTerminalCall> lookaheadStack= new ArrayList<> ();
    /**
 * Inner class that represents entering a grammar production
 */
    class NonTerminalCall {
        final String sourceFile;
        final String productionName;
        final int offset;
        // We actually only use this when we're working with the LookaheadStack
        final boolean scanToEnd;
        NonTerminalCall(String sourceFile, String productionName, int offset) {
            this.sourceFile= sourceFile;
            this.productionName= productionName;
            this.offset= offset;
            this.scanToEnd= JasminParser.this.scanToEnd;
        }

        final JasminParserLexer getTokenSource() {
            return JasminParser.this.token_source;
        }

        final int getLine() {
            return getTokenSource().getLineFromOffset(offset);
        }

        final int getColumn() {
            return getTokenSource().getCodePointColumnFromOffset(offset);
        }

        StackTraceElement createStackTraceElement() {
            return new StackTraceElement("JasminParser", productionName, sourceFile, getLine());
        }

        void dump(PrintStream ps) {
            ps.println(productionName+":"+getLine()+":"+getColumn());
        }

    }
    private final void pushOntoCallStack(String methodName, String fileName, int offset) {
        parsingStack.add(new NonTerminalCall(fileName, methodName, offset));
    }

    private final void popCallStack() {
        NonTerminalCall ntc= parsingStack.remove(parsingStack.size()-1);
        this.currentlyParsedProduction= ntc.productionName;
    }

    private final void restoreCallStack(int prevSize) {
        while (parsingStack.size()> prevSize) {
            popCallStack();
        }
    }

    void dumpLookaheadStack(PrintStream ps) {
        ListIterator<NonTerminalCall> it= lookaheadStack.listIterator(lookaheadStack.size());
        while (it.hasPrevious()) {
            it.previous().dump(ps);
        }
    }

    void dumpCallStack(PrintStream ps) {
        ListIterator<NonTerminalCall> it= parsingStack.listIterator(parsingStack.size());
        while (it.hasPrevious()) {
            it.previous().dump(ps);
        }
    }

    void dumpLookaheadCallStack(PrintStream ps) {
        ps.println("Current Parser Production is: "+currentlyParsedProduction);
        ps.println("Current Lookahead Production is: "+currentLookaheadProduction);
        ps.println("---Lookahead Stack---");
        dumpLookaheadStack(ps);
        ps.println("---Call Stack---");
        dumpCallStack(ps);
    }

    public boolean isParserTolerant() {
        return false;
    }

    public void setParserTolerant(boolean tolerantParsing) {
        if (tolerantParsing) {
            throw new UnsupportedOperationException("This parser was not built with that feature!");
        }
    }

    private Token consumeToken(TokenType expectedType) {
        Token oldToken= lastConsumedToken;
        Token nextToken= nextToken(lastConsumedToken);
        if (nextToken.getType()!=expectedType) {
            nextToken= handleUnexpectedTokenType(expectedType, nextToken);
        }
        this.lastConsumedToken= nextToken;
        this.nextTokenType= null;
        if (buildTree&&tokensAreNodes) {
            pushNode(lastConsumedToken);
        }
        return lastConsumedToken;
    }

    private Token handleUnexpectedTokenType(TokenType expectedType, Token nextToken) {
        throw new ParseException(nextToken, EnumSet.of(expectedType), parsingStack);
    }

    private class ParseState {
        Token lastConsumed;
        ArrayList<NonTerminalCall> parsingStack;
        NodeScope nodeScope;
        ParseState() {
            this.lastConsumed= JasminParser.this.lastConsumedToken;
            @SuppressWarnings("unchecked")
            ArrayList<NonTerminalCall> parsingStack= (ArrayList<NonTerminalCall> ) JasminParser.this.parsingStack.clone();
            this.parsingStack= parsingStack;
            this.nodeScope= (NodeScope) currentNodeScope.clone();
        }

    }
    private boolean buildTree= true;
    private boolean tokensAreNodes= true;
    private boolean unparsedTokensAreNodes= false;
    public boolean isTreeBuildingEnabled() {
        return buildTree;
    }

    public void setUnparsedTokensAreNodes(boolean unparsedTokensAreNodes) {
        this.unparsedTokensAreNodes= unparsedTokensAreNodes;
    }

    public void setTokensAreNodes(boolean tokensAreNodes) {
        this.tokensAreNodes= tokensAreNodes;
    }

    NodeScope currentNodeScope= new NodeScope();
    /** 
         * @return the root node of the AST. It only makes sense to call
         * this after a successful parse. 
         */
    public Node rootNode() {
        return currentNodeScope.rootNode();
    }

    /**
     * push a node onto the top of the node stack
     * @param n the node to push
     */
    public void pushNode(Node n) {
        currentNodeScope.add(n);
    }

    /** 
     * @return the node on the top of the stack, and remove it from the
     * stack.  
     */
    public Node popNode() {
        return currentNodeScope.pop();
    }

    /** 
     * @return the node currently on the top of the tree-building stack. 
     */
    public Node peekNode() {
        return currentNodeScope.peek();
    }

    /**
     * Puts the node on the top of the stack. However, unlike pushNode()
     * it replaces the node that is currently on the top of the stack.
     * This is effectively equivalent to popNode() followed by pushNode(n)
     * @param n the node to poke
     */
    public void pokeNode(Node n) {
        currentNodeScope.poke(n);
    }

    /** 
     * @return the number of Nodes on the tree-building stack in the current node
         * scope. 
         */
    public int nodeArity() {
        return currentNodeScope.size();
    }

    private void clearNodeScope() {
        currentNodeScope.clear();
    }

    private void openNodeScope(Node n) {
        new NodeScope();
        if (n!=null) {
            Token next= nextToken(lastConsumedToken);
            n.setTokenSource(lastConsumedToken.getTokenSource());
            n.setBeginOffset(next.getBeginOffset());
            n.open();
        }
    }

    /* A definite node is constructed from a specified number of
         * children.  That number of nodes are popped from the stack and
         * made the children of the definite node.  Then the definite node
         * is pushed on to the stack.
         */
    private void closeNodeScope(Node n, int num) {
        n.setEndOffset(lastConsumedToken.getEndOffset());
        currentNodeScope.close();
        ArrayList<Node> nodes= new ArrayList<Node> ();
        for (int i= 0; i<num; i++) {
            nodes.add(popNode());
        }
        Collections.reverse(nodes);
        for (Node child : nodes) {
            // FIXME deal with the UNPARSED_TOKENS_ARE_NODES case
            n.addChild(child);
        }
        n.close();
        pushNode(n);
    }

    /**
         * A conditional node is constructed if the condition is true.  All
         * the nodes that have been pushed since the node was opened are
         * made children of the conditional node, which is then pushed
         * on to the stack.  If the condition is false the node is not
         * constructed and they are left on the stack. 
         */
    private void closeNodeScope(Node n, boolean condition) {
        if (n!=null&&condition) {
            n.setEndOffset(lastConsumedToken.getEndOffset());
            int a= nodeArity();
            currentNodeScope.close();
            ArrayList<Node> nodes= new ArrayList<Node> ();
            while (a--> 0) {
                nodes.add(popNode());
            }
            Collections.reverse(nodes);
            for (Node child : nodes) {
                if (unparsedTokensAreNodes&&child instanceof Token) {
                    Token tok= (Token) child;
                    while (tok.previousCachedToken()!=null&&tok.previousCachedToken().isUnparsed()) {
                        tok= tok.previousCachedToken();
                    }
                    while (tok.isUnparsed()) {
                        n.addChild(tok);
                        tok= tok.nextCachedToken();
                    }
                }
                n.addChild(child);
            }
            n.close();
            pushNode(n);
        }
        else  {
            currentNodeScope.close();
        }
    }

    public boolean getBuildTree() {
        return buildTree;
    }

    public void setBuildTree(boolean buildTree) {
        this.buildTree= buildTree;
    }

    /**
     * Just a kludge so that existing jjtree-based code that uses
     * parser.jjtree.foo can work without change.
     */
    JasminParser jjtree= this;
    @SuppressWarnings("serial")
    class NodeScope extends ArrayList<Node>  {
        NodeScope parentScope;
        NodeScope() {
            this.parentScope= JasminParser.this.currentNodeScope;
            JasminParser.this.currentNodeScope= this;
        }

        boolean isRootScope() {
            return parentScope== null;
        }

        Node rootNode() {
            NodeScope ns= this;
            while (ns.parentScope!=null) {
                ns= ns.parentScope;
            }
            return ns.isEmpty()?null:
            ns.get(0);
        }

        Node peek() {
            return isEmpty()?parentScope.peek():
            get(size()-1);
        }

        Node pop() {
            return isEmpty()?parentScope.pop():
            remove(size()-1);
        }

        void poke(Node n) {
            if (isEmpty()) {
                parentScope.poke(n);
            }
            else  {
                set(size()-1, n);
            }
        }

        void close() {
            parentScope.addAll(this);
            JasminParser.this.currentNodeScope= parentScope;
        }

        int nestingLevel() {
            int result= 0;
            NodeScope parent= this;
            while (parent.parentScope!=null) {
                result++;
                parent= parent.parentScope;
            }
            return result;
        }

        public NodeScope clone() {
            NodeScope clone= (NodeScope) super.clone();
            if (parentScope!=null) {
                clone.parentScope= (NodeScope) parentScope.clone();
            }
            return clone;
        }

    }
}
